const e=e=>e[Math.floor(Math.random()*e.length)],r=r=>{if(!Array.isArray(r))throw new TypeError("values should be an array in createGenerator(values)");return t=>{if(void 0===t)return e(r);if("function"==typeof t)return t(e(r));throw new TypeError("middleware should be a function or undefined in createGenerator(values)(middleware)")}},t=(r={})=>{if("[object Object]"!==Object.prototype.toString.call(r))throw new TypeError("schemaDefinition should be an object or empty in createObjectGenerator(schemaDefinition)");return(o={})=>{if("[object Object]"!==Object.prototype.toString.call(o))throw new TypeError("middlewares should be an object or empty in createObjectGenerator(schemaDefinition)(middlewares)");const n={};for(const a in r){if(!Object.prototype.hasOwnProperty.call(r,a))continue;const i=r[a];if(Array.isArray(i)){const r=e(i),t=o[a];if("function"==typeof t){n[a]=t(r);continue}n[a]=r}else{if("[object Object]"!==Object.prototype.toString.call(i))throw new TypeError("values should either be an array or an object in createObjectGenerator({something: values})");{const e=o[a],r=t(i)(e);n[a]=r}}}return n}};export{r as createGenerator,t as createObjectGenerator};
